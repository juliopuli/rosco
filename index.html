<script>
    // ... (Variables de MQTT y Bancos de preguntas se mantienen iguales) ...

    function responder(tipo) {
        if(!miTurno) return;
        let pIdx = (miRol === 'host' ? idxJ1 : idxJ2);
        let listaP = (miRol === 'host' ? preguntasJ1 : preguntasJ2);
        let estados = (miRol === 'host' ? estJ1 : estJ2);
        const target = listaP[pIdx].respuesta;
        let res = 'pendiente';

        if(tipo === 'ok') {
            const u = document.getElementById('ans').value.trim();
            
            // VALIDACIÓN FLEXIBLE
            if(validarFlex(u, target)) {
                res = 'acierto';
                document.getElementById('msg-alerta').innerText = "¡CORRECTO! (Aceptada)";
            } else {
                res = 'fallo';
                miTurno = false;
                document.getElementById('msg-alerta').innerText = "ERROR: ERA " + target.toUpperCase();
            }
        } else {
            miTurno = false;
            document.getElementById('msg-alerta').innerText = "PASAPALABRA";
        }

        // ... (Lógica de guardado y avance de índice igual que antes) ...
        estados[pIdx] = res;
        let next = pIdx;
        do { next = (next + 1) % listaP.length; } while(estados[next] !== 'pendiente' && estados.includes('pendiente'));
        if(miRol === 'host') idxJ1 = next; else idxJ2 = next;

        client.publish("pasa/sala/" + salaID, JSON.stringify({
            tipo: 'ACCION', player: miRol, idx: pIdx, res: res, target: target, nextIdx: next
        }));
        
        document.getElementById('ans').value = "";
        dibujar();
    }

    // FUNCIÓN DE VALIDACIÓN MÁGICA
    function validarFlex(usuario, correcta) {
        // 1. Limpiar tildes y pasar a minúsculas
        const limpiar = (str) => str.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
        
        let u = limpiar(usuario);
        let c = limpiar(correcta);

        // 2. Si son iguales tras quitar tildes
        if (u === c) return true;

        // 3. Algoritmo de Distancia de Levenshtein (permite 1 error)
        return levenshtein(u, c) <= 1; 
    }

    function levenshtein(a, b) {
        const matrix = [];
        for (let i = 0; i <= b.length; i++) matrix[i] = [i];
        for (let j = 0; j <= a.length; j++) matrix[0][j] = j;

        for (let i = 1; i <= b.length; i++) {
            for (let j = 1; j <= a.length; j++) {
                if (b.charAt(i - 1) === a.charAt(j - 1)) {
                    matrix[i][j] = matrix[i - 1][j - 1];
                } else {
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j - 1] + 1, // sustitución
                        matrix[i][j - 1] + 1,     // inserción
                        matrix[i - 1][j] + 1      // eliminación
                    );
                }
            }
        }
        return matrix[b.length][a.length];
    }
</script>
